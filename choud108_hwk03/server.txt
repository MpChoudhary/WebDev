#!/usr/bin/env python3

# See https://docs.python.org/3.x/library/socket.html
# for a description of python socket and its parameters
#
# Copyright 2018, Mukesh P Choudhary, All rights reserved.

import os
import signal
import sys
import socket
import threading
import urllib.parse
import datetime

from stat import ST_MODE, S_IROTH, S_IWOTH

DEFAULT_PORT = 9001

# Number of bytes to read from the socket at a time
BUFSIZE = 4096

# Location of files to be served
ROOT = '.'

CRLF = '\r\n'

# Status codes and messages
status_message_response = {
    200: 'OK',
    301: 'Moved Permanantly',
    400: 'Bad Request',
    403: 'Forbidden',
    404: 'Not Found',
    405: 'Method Not Allowed',
    406: 'Not Acceptable',
}


def main():
    host = ''
    # Use port from command line, or default if none was provided
    try:
        port = int(sys.argv[1]) if len(sys.argv) > 1 else DEFAULT_PORT
    except ValueError:
        # int value error
        port = DEFAULT_PORT

    # Set up socket
    try:
        httpserversocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        httpserversocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        httpserversocket.bind((host, port))
    except Exception:
        print('Failed to create socket')
        raise

    httpserversocket.listen(10)
    print('Listening on port', port)

    def handler(signum, frame):
        '''Close socket on SIGINT before exiting'''
        print('\b\bShutting down server')
        httpserversocket.close()
        sys.exit(0)

    signal.signal(signal.SIGINT, handler)

    os.chdir(ROOT)
    while True:
        (client, address) = httpserversocket.accept()
        th = threading.Thread(target=http_server, args=[client, address])
        th.daemon = True
        th.start()

# Accept request and process request in this function
def http_server(client, address):
    '''Entrypoint for each new HTTP request'''
    ip_address = address[0]
    port = address[1]

    try:
        # Read request
        raw_request = b''
        while True:
            portion = client.recv(BUFSIZE)
            raw_request += portion
            if len(portion) < BUFSIZE:
                break
        raw_request = raw_request.decode()

        # Parse fields
        request_lines = raw_request.split(CRLF)
        request = request_lines[0]
        request_fields = request.split()
        method = request_fields[0]
        uri = request_fields[1]
        version = request_fields[2]
        body_index = request_lines.index('') + 1
        request_headers_list = request_lines[1:body_index-1]
        request_headers = {}

        # log request headers
        print('REQUEST_HEADERS:\n{}'.format(request))
        print(*request_headers_list, sep='\n')
        for rh in request_headers_list:
            spl = rh.split(':')
            first = spl[0]
            jn = ':'.join(spl[1:])[1:]
            request_headers[first] = jn
        # print('REQUEST_HEAD: {}\n'.format(request_headers))
        request_body = CRLF.join(request_lines[body_index:])

        # log request body
        print('REQUEST_BODY: {}\n'.format(request_body))
        # Read requested file
        relative_path = uri[1:].split('?')[0]
        if relative_path.split('/')[-1] == 'umntc':
            content = ''
            status = 301
            headers = 'Location: https://www.twin-cities.umn.edu'
        else:
            try:
                # Call appropriate HTTP method
                content, status, headers = methods[method](relative_path, request_body)
            except KeyError:
                # Method not allowed
                content, status, headers = error(405)

        if not acceptable(request_headers, relative_path):
            content, status, headers = error(406)

        # Format response
        response = '{} {} {}\r\n'.format(
            version, status, status_message_response[status])

        print('RESPONSE:\n{}'.format(response))
        response += headers + CRLF
        response = response.encode()
        try:
            content = content.encode()
        except AttributeError:
            # Content is binary, already encoded
            pass
        response += content

        # Log request and status code
        print('"{}" {} {}'.format(request, status, len(response)))
        # Respond to client
        client.send(response)
    finally:
        client.close()

# http METHODS
def get(path, data):
    # HTTP GET method
    headers = ''

    # Read requested file
    if not os.path.exists(path):
        # File does not exist
        return error(404)
    elif os.path.exists(path) and not check_perms(path):
        # Permissions don't allow this file to be read by others
        return error(403)
    else:
        # OK status
        status = 200
        try:
            with open(path, 'r') as f:
                content = f.read()
        except UnicodeDecodeError:
            # File is binary
            with open(path, 'rb') as f:
                content = f.read()
        return content, status, headers


def head(path, data):
    _, status, headers = get(path, data)
    return '', status, headers

def post(path, data):
    # Parse form data
    data_list = data.split('&')

    # Dictionary of all form data keys and values
    data = {}

    for dl in data_list:
        try:
            k, v = dl.split('=')
        except ValueError:
            continue

        # Bring back escaped characters
        v = urllib.parse.unquote_plus(v)

        data[k] = v

    if path == '':
        # Coming from form.html
        try:
            # Extract values
            Eventname = data['eventname']
            Starttime = data['starttime']
            Endtime = data['endtime']
            Location = data['location']
            Day = data['day']
        except KeyError:
            # Some parameter was ommitted
            return error(400)

        # Response
        status = 200
        headers = ''
        content = '\n'.join((
            "<html>",
            "<body>",
            "<h2> Following Form Data Submitted Successfully </h2>",
            "<p> Event Name: {} <p>",
            "<p> Start Time:  {} <p>",
            "<p> End time: {} <p>",
            "<p> Location: {} <p>",
            "<p> Day: {} <p>",

            "</body>",
            "</html>",
        )).format(Eventname, Startime, Endtime, Location, Day)
        return content, status, headers
    elif os.path.exists(path):
        if not check_perms(path):
            return error(403)
        else:
            return error(405)
    else:
        return error(404)

# HTTP request methods and their corresponding functions
methods = {
    'GET': get,
    'HEAD': head,
    'POST': post,
}

# HELPER FUNCTIONS
def check_perms(path):
    return os.stat(path)[ST_MODE] & S_IROTH

def error(status):
    '''Response from an error code'''
    if status == 403 or status == 404 or status == 405:
        headers = 'Connection: close'
    else:
        headers = ''
    try:
        with open(str(status) + '.html', 'r') as f:
            content = f.read()
    except IOError:
        content = '{} - {}'.format(status, status_message_response[status])
    return content, status, headers

def acceptable(r_headers, path):
    '''Check if the request's acceptable types match the requested resource'''
    if 'Accept' not in r_headers:
        return True

    accept = r_headers['Accept'].split(',')
    for i in list(range(len(accept))):
        accept[i] = accept[i].split(';')[0]

    if '*/*' in accept:
        return True

    res = path.split('.')[-1]
    if res == 'html' or res == 'htm':
        return 'text/*' in accept or 'text/html' in accept
    elif res == 'js':
        return 'text/*' in accept or 'text/javascript' in accept
    elif res == 'css':
        return 'text/*' in accept or 'text/css' in accept
    elif res == 'css':
        return 'image/*' in accept or 'image/png' in accept
    elif res == 'jpg' or res == 'jpeg':
        return 'image/*' in accept or 'image/jpeg' in accept
    elif res == 'gif':
        return 'image/*' in accept or 'image/gif' in accept
    elif res == 'mp3':
        return 'audio/*' in accept or 'audio/mp3' in accept
    else:
        return False


if __name__ == '__main__':
    main()
